<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cestini</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* Stili Desktop (default) */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex; /* La sidebar è a destra della mappa */
            height: 100vh;
            overflow: hidden; /* Evita lo scroll indesiderato */
            -webkit-user-select: none; /* Chrome, Safari, Opera */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer / Edge legacy */
            user-select: none;         /* Standard */
        }
        #map {
            flex-grow: 1; /* La mappa occupa tutto lo spazio disponibile */
            height: 100%;
            width: 100%; /* Inizialmente occupa tutta la larghezza rimanente */
        }
        #sidebar {
            width: 320px; /* Larghezza fissa per desktop */
            flex-shrink: 0; /* Impedisce che la sidebar si restringa */
            background: #f8f9fa;
            padding: 20px; /* Padding originale per desktop */
            overflow-y: auto; /* Permette lo scroll del contenuto se in eccesso */
            box-shadow: -2px 0 5px rgba(0,0,0,0.1); /* Ombra a sinistra */
            z-index: 10;
            border-radius: 12px 0 0 12px; /* Angoli arrotondati in alto a destra per desktop */
            transition: all 0.3s ease-out; /* Transizione per proprietà che potrebbero cambiare */
            display: flex; /* Per layout interno della sidebar */
            flex-direction: column;
        }

        /* Stili Popup Mapbox (rimangono uguali) */
        .mapboxgl-popup { max-width: 250px; }
        .mapboxgl-popup-content { text-align: left; font-size: 14px; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); }
        .mapboxgl-popup-content h3 { margin: 0 0 5px 0; font-size: 16px; color: #333; }
        .mapboxgl-popup-content p { margin: 0; }

        /* Overrides specifici per Mobile */
        @media (max-width: 768px) {
            body {
                flex-direction: column; /* Impila mappa e sidebar verticalmente */
                position: relative; /* Per posizionamento fisso della sidebar */
            }

            #map {
                /* Altezza iniziale della mappa per lasciare spazio al handle del menu (60px) */
                height: calc(100vh - 60px);
                transition: height 0.3s ease-out; /* Transizione fluida per l'altezza della mappa */
            }

            #sidebar {
                position: fixed; /* Posizione fissa in basso */
                bottom: 0;
                left: 0;
                width: 100%; /* Larghezza piena per mobile */
                height: 80vh; /* Altezza massima quando completamente aperto (80% del viewport) */
                max-height: 80vh; /* Assicura che non superi questa altezza */
                transform: translateY(calc(80vh - 60px)); /* Nascondi inizialmente la maggior parte, lascia 60px visibili */
                box-shadow: 0 -2px 10px rgba(0,0,0,0.15); /* Ombra in alto per separare dalla mappa */
                border-radius: 38.5px 38.5px 0 0; /* Angoli arrotondati in alto per mobile */
                padding: 0; /* Padding gestito internamente per mobile */
                z-index: 1000; /* Assicura che sia sopra gli altri elementi */
                overflow: hidden; /* Nasconde lo scrollbar quando è collassato, ma il contenuto è visibile */
                transition: transform 0.3s ease-out; /* Transizione per l'apertura/chiusura */
            }

            #sidebar.is-open {
                transform: translateY(0); /* Completamente aperto */
                box-shadow: 0 -2px 10px rgba(0,0,0,0.25); /* Ombra leggermente più pronunciata quando aperto */
                overflow-y: auto; /* Abilita lo scroll per la sidebar quando aperta */
            }

            #mobile-sidebar-handle {
                width: 100%;
                height: 60px; /* Altezza visibile del handle quando il menu è chiuso */
                background-color: #f8f9fa;
                border-radius: 38.5px 38.5px 0 0;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-shrink: 0; /* Impedisce che si riduca */
                position: relative;
                z-index: 1001; /* Assicurati che sia sopra il contenuto scorrevole */
                cursor: grab; /* Indica che è trascinabile */
                touch-action: none; /* Previene azioni touch predefinite del browser */
            }

            #mobile-sidebar-handle::before {
                content: '';
                width: 40px;
                height: 4px;
                background-color: #ccc;
                border-radius: 2px;
            }

            /* Contenuto scorrevole per mobile */
            #sidebar-scrollable-content {
                flex-grow: 1; /* Permette alla sezione di crescere e occupare lo spazio disponibile */
                overflow-y: auto; /* Abilita lo scroll per questa sezione */
                padding: 0 15px 15px 15px; /* Applica padding al contenuto scorrevole per mobile */
            }

            /* Sezione delle azioni (bottoni) fissa in fondo per mobile */
            #sidebar-actions {
                flex-shrink: 0; /* Impedisce alla sezione azioni di restringersi */
                padding: 15px; /* Padding per i bottoni */
                background: #f8f9fa; /* Assicurati che abbia lo stesso sfondo della sidebar */
                box-shadow: 0 -2px 5px rgba(0,0,0,0.05); /* Leggera ombra sopra per separare */
                border-radius: 0 0 12px 12px; /* Angoli arrotondati in basso */
                position: sticky; /* Rende la sezione "appiccicosa" */
                bottom: 0; /* La attacca al fondo del suo contenitore */
                z-index: 1002; /* Assicurati che sia sopra il contenuto scorrevole */
            }
        }
        
        ::-webkit-scrollbar {
            display: none; /* Chrome, Safari, Opera */
        }
        
        html, body {
            -ms-overflow-style: none;  /* Internet Explorer e Edge legacy */
            scrollbar-width: none;     /* Firefox */
        }

        /* Nasconde il handle e assicura visibilità del contenuto su desktop */
        @media (min-width: 769px) {
            #mobile-sidebar-handle {
                display: none; /* Nasconde il handle su desktop */
            }
            #sidebar-scrollable-content {
                opacity: 1;
                visibility: visible;
                max-height: none; /* Reset per desktop */
                overflow-y: auto; /* Abilita scrollbar per desktop */
                padding: 0; /* Reset padding specifico per mobile dal contenuto su desktop */
            }
            #sidebar-actions {
                position: static; /* Rimuovi sticky positioning su desktop */
                box-shadow: none; /* Rimuovi ombra su desktop */
                border-radius: 0; /* Rimuovi angoli arrotondati su desktop */
                padding: 0; /* Il padding generale della sidebar gestirà questo */
            }
        }

        /* Stili per nascondere temporaneamente i controlli Mapbox */
        .mapboxgl-ctrl-hide-for-screenshot {
            display: none !important;
        }
    </style>
</head>
<body>
<div id="sidebar">
    <!-- Handle per mobile (visibile solo su mobile) -->
    <div id="mobile-sidebar-handle"></div>

    <!-- Wrapper per il contenuto principale della sidebar -->
    <div class="flex flex-col flex-grow">
        <!-- Sezione informativa iniziale -->
        <div class="p-4 md:p-0"> <!-- Aggiungi padding su mobile, resetta per desktop con md:p-0 se sidebar ha già padding -->
            <h1 class="text-2xl font-bold text-gray-800">Mappa Cestini</h1>
            <p class="text-sm text-gray-600">Filtra e interagisci con i punti sulla mappa.</p>
        </div>

        <!-- Il contenuto della sidebar ora è diviso in sezioni -->
        <!-- Questa è la sezione scorrevole per i filtri -->
        <div id="sidebar-scrollable-content" class="flex-grow md:p-0">
            <div id="filter-container">
                <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">Filtra per tipo</h2>
                <div id="filters" class="space-y-2"><div class="text-center text-gray-500 p-4"><p>Caricamento filtri...</p></div></div>
            </div>

            <div class="mt-8">
                <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">La tua posizione</h2>
                <button id="locate-me-button" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 shadow-md">Trova la mia posizione</button>
                <div id="closest-point-info" class="mt-4 p-4 bg-gray-100 rounded-lg shadow-sm hidden">
                    <h3 class="text-md font-bold text-gray-800 mb-2">Punto più vicino:</h3>
                    <div id="closest-point-details" class="text-sm text-gray-700 space-y-1">
                        <!-- Dettagli del punto più vicino verranno inseriti qui -->
                    </div>
                    <button id="get-directions-button" class="w-full mt-4 bg-purple-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-700 transition duration-300 shadow-md">Ottieni indicazioni</button>
                </div>
            </div>
        </div>

        <!-- Questa è la sezione per i bottoni, che rimarrà fissa in fondo su mobile -->
        <div id="sidebar-actions" class="space-y-3">
            <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">Azioni</h2>
            <button id="center-button" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 shadow-md">Centra sui punti visibili</button>
            <button id="screenshot-button" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 shadow-md">Cattura Screenshot</button>
        </div>
    </div>
</div>
<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoicXdhbWR5IiwiYSI6ImNtZWNpajBvNTFqMGQybHF2d3NtemprNGUifQ.YVS-mtfbzisMPLhTO_dtAw';
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [10.5274, 42.92511],
    zoom: 13.89,
    preserveDrawingBuffer: true
});
map.addControl(new mapboxgl.NavigationControl());

const layerId = 'cestini-layer';
const bidoniVSquareLayerId = 'bidoni-v-square-layer'; // Nuovo ID per il layer dei bidoni-V quadrati
const userLocationLayerId = 'user-location-layer'; // ID per il layer della posizione utente
const closestPointLayerId = 'closest-point-layer'; // ID per il layer del punto più vicino

// Variabile globale per memorizzare i dati GeoJSON completi
let fullGeojsonData = null;
let userLngLat = null; // Memorizza la posizione attuale dell'utente
let closestFeatureCoords = null; // Memorizza le coordinate del punto più vicino selezionato

// Data URL per un'icona quadrata SVG che può essere colorata
const squareSvgString = `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="24" height="24" fill="currentColor"/></svg>`;
const squareImage = new Image(24, 24);
squareImage.src = 'data:image/svg+xml;base64,' + btoa(squareSvgString);

// Carica il GeoJSON
fetch('cestini.geojson')
    .then(res => res.json())
    .then(data => {
        fullGeojsonData = data; // Memorizza i dati completi globalmente
        map.on('load', () => {
            // Aggiungi l'icona quadrata alla mappa
            map.addImage('square-icon', squareImage);

            map.addSource(layerId, { type: 'geojson', data });

            // Layer per tutti i cerchi ECCETTO 'Bidoni-V'
            map.addLayer({
                id: layerId,
                type: 'circle',
                source: layerId,
                filter: ['!=', 'type', 'Bidoni-V'], // Escludi i Bidoni-V da questo layer
                paint: {
                    'circle-radius': 5, // punti più piccoli
                    'circle-color': [
                        'to-color',
                        ['get', 'colour'] // prende il valore dalla proprietà "colour"
                    ],
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#333'
                }
            });

            // Nuovo layer per 'Bidoni-V' come quadrati
            map.addLayer({
                id: bidoniVSquareLayerId,
                type: 'symbol',
                source: layerId,
                filter: ['==', 'type', 'Bidoni-V'], // Solo i Bidoni-V per questo layer
                layout: {
                    'icon-image': 'square-icon', // Usa l'icona quadrata personalizzata
                    'icon-size': 0.6, // Rendi l'icona leggermente più grande (es. 0.6 della dimensione originale di 24px)
                    'icon-allow-overlap': true, // Permetti alle icone di sovrapporsi
                    'icon-anchor': 'center' // Centra l'icona sulla coordinata
                },
                paint: {
                    'icon-color': ['to-color', ['get', 'colour']] // Usa la proprietà 'colour' per la tinta
                }
            });

            // Layer per la posizione dell'utente (inizialmente vuoto)
            map.addSource(userLocationLayerId, {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });
            map.addLayer({
                id: userLocationLayerId,
                type: 'circle',
                source: userLocationLayerId,
                paint: {
                    'circle-radius': 8,
                    'circle-color': '#007cbf',
                    'circle-stroke-width': 2,
                    'circle-stroke-color': '#ffffff'
                }
            });

            // Layer per evidenziare il punto più vicino (inizialmente vuoto)
            map.addSource(closestPointLayerId, {
                type: 'geojson',
                data: {
                    type: 'FeatureCollection',
                    features: []
                }
            });
            map.addLayer({
                id: closestPointLayerId,
                type: 'circle', // Useremo un cerchio più grande e distinto
                source: closestPointLayerId,
                paint: {
                    'circle-radius': 12,
                    'circle-color': '#ff0000', // Colore rosso per evidenziare
                    'circle-stroke-width': 3,
                    'circle-stroke-color': '#ffffff',
                    'circle-opacity': 0.8
                }
            });

            // Popup su click - ora gestisce tutti i layer rilevanti
            map.on('click', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], (e) => {
                const coords = e.features[0].geometry.coordinates.slice();
                const props = e.features[0].properties;
                let html = `<h3 class="font-bold capitalize">${props.type || 'Dettagli'}</h3><div class="mt-2 space-y-1">`;
                for (const k in props) {
                    if (k === 'colour' || typeof props[k] === 'boolean' || k === 'isUserLocation' || k === 'isClosestPoint') continue;
                    html += `<p><strong>${k.charAt(0).toUpperCase() + k.slice(1)}:</strong> ${props[k]}</p>`;
                }
                html += '</div>';
                new mapboxgl.Popup().setLngLat(coords).setHTML(html).addTo(map);
            });

            // Cambia cursore su hover - ora gestisce tutti i layer rilevanti
            map.on('mouseenter', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], () => { map.getCanvas().style.cursor = 'pointer'; });
            map.on('mouseleave', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], () => { map.getCanvas().style.cursor = ''; });

            generateFilters(data);
        });
    })
    .catch(err => {
        console.error('Errore caricamento GeoJSON:', err);
        document.getElementById('filters').innerHTML = '<p class="text-red-500">Errore caricamento dati.</p>';
    });

function generateFilters(data) {
    const features = data.features;
    const types = new Set(features.map(f => f.properties?.type).filter(type => type != null));
    const container = document.getElementById('filters');
    container.innerHTML = '';
    if (!types.size) {
        container.innerHTML = '<p class="text-gray-500">Nessun attributo "type" trovato.</p>';
        return;
    }
    Array.from(types).sort().forEach(type => {
        const id = `filter-${type.replace(/\s+/g, '-')}`;
        const label = document.createElement('label');
        label.htmlFor = id;
        label.className = 'flex items-center space-x-3 p-2 rounded-md hover:bg-gray-200 cursor-pointer';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = id;
        cb.value = type;
        cb.checked = true;
        cb.className = 'h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500';
        cb.addEventListener('change', updateFilters);

        const span = document.createElement('span');
        span.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        span.className = 'text-gray-700';

        label.appendChild(cb);
        label.appendChild(span);
        container.appendChild(label);
    });
}

function updateFilters() {
    const checked = Array.from(document.querySelectorAll('#filters input[type="checkbox"]'))
        .filter(cb => cb.checked)
        .map(cb => cb.value);

    // Filtro per i cerchi (tutti i tipi TRANNE 'Bidoni-V')
    let circleFilter;
    if (!checked.length) {
        circleFilter = ['==', 'type', '']; // Nascondi tutti i cerchi
    } else {
        const filteredChecked = checked.filter(type => type !== 'Bidoni-V');
        if (filteredChecked.length > 0) {
            circleFilter = ['all', ['!=', 'type', 'Bidoni-V'], ['in', 'type', ...filteredChecked]];
        } else {
            circleFilter = ['==', 'type', '']; // Nessun tipo non-'Bidoni-V' selezionato, nascondi tutti i cerchi
        }
    }
    map.setFilter(layerId, circleFilter);

    // Filtro per i quadrati (solo 'Bidoni-V')
    let squareFilter;
    if (checked.includes('Bidoni-V')) {
        squareFilter = ['==', 'type', 'Bidoni-V']; // Mostra i quadrati Bidoni-V
    } else {
        squareFilter = ['==', 'type', '']; // Nascondi i quadrati Bidoni-V
    }
    map.setFilter(bidoniVSquareLayerId, squareFilter);
}

document.getElementById('center-button').addEventListener('click', () => {
    // Questo pulsante ora centra sui punti VISIBILI renderizzati di ENTRAMBI i layer
    const features = map.queryRenderedFeatures({ layers: [layerId, bidoniVSquareLayerId] });
    if (!features.length) { return; }
    const bounds = new mapboxgl.LngLatBounds();
    features.forEach(f => bounds.extend(f.geometry.coordinates));
    map.fitBounds(bounds, { padding: 80, maxZoom: 16 });
});


// Funzione per calcolare la distanza Haversine tra due punti (in km)
function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Raggio della Terra in chilometri
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    const distance = R * c; // Distanza in km
    return distance;
}

// Funzione per trovare il punto più vicino all'utente
function findClosestPoint(userLng, userLat) {
    if (!fullGeojsonData || !fullGeojsonData.features.length) {
        console.warn('Dati GeoJSON non disponibili per trovare il punto più vicino.');
        return null;
    }

    let closest = null;
    let minDistance = Infinity;

    fullGeojsonData.features.forEach(feature => {
        const coords = feature.geometry.coordinates;
        const distance = calculateDistance(userLat, userLng, coords[1], coords[0]);

        if (distance < minDistance) {
            minDistance = distance;
            closest = feature;
        }
    });

    if (closest) {
        return { feature: closest, distance: minDistance };
    }
    return null;
}

// Elementi DOM per la gestione della posizione utente e punto più vicino
const locateMeButton = document.getElementById('locate-me-button');
const closestPointInfo = document.getElementById('closest-point-info');
const closestPointDetails = document.getElementById('closest-point-details');
const getDirectionsButton = document.getElementById('get-directions-button');

locateMeButton.addEventListener('click', () => {
    if (navigator.geolocation) {
        locateMeButton.textContent = 'Ricerca posizione...';
        locateMeButton.disabled = true;
        navigator.geolocation.getCurrentPosition(
            (position) => {
                const { latitude, longitude } = position.coords;
                userLngLat = [longitude, latitude];
                console.log('Posizione utente:', userLngLat);

                // Aggiorna la sorgente della posizione utente sulla mappa
                map.getSource(userLocationLayerId).setData({
                    type: 'FeatureCollection',
                    features: [{
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: userLngLat
                        },
                        properties: {
                            description: 'La tua posizione',
                            isUserLocation: true
                        }
                    }]
                });

                // Centra la mappa sulla posizione dell'utente
                map.flyTo({ center: userLngLat, zoom: 15 });

                // Trova il punto più vicino
                const result = findClosestPoint(longitude, latitude);
                if (result) {
                    const { feature, distance } = result;
                    closestFeatureCoords = feature.geometry.coordinates;
                    console.log('Punto più vicino:', feature.properties.type, 'a', distance.toFixed(2), 'km');

                    // Aggiorna la sidebar con i dettagli del punto più vicino
                    let detailsHtml = `<p><strong>Tipo:</strong> ${feature.properties.type || 'N/A'}</p>`;
                    detailsHtml += `<p><strong>Distanza:</strong> ${distance.toFixed(2)} km</p>`;
                    // Aggiungi altre proprietà se presenti e significative
                    if (feature.properties.name) detailsHtml += `<p><strong>Nome:</strong> ${feature.properties.name}</p>`;
                    closestPointDetails.innerHTML = detailsHtml;
                    closestPointInfo.classList.remove('hidden');

                    // Aggiorna la sorgente del punto più vicino sulla mappa
                    map.getSource(closestPointLayerId).setData({
                        type: 'FeatureCollection',
                        features: [{
                            type: 'Feature',
                            geometry: {
                                type: 'Point',
                                coordinates: closestFeatureCoords
                            },
                            properties: {
                                description: 'Punto più vicino',
                                isClosestPoint: true,
                                ...feature.properties // Copia le proprietà originali
                            }
                        }]
                    });

                    // Centra la mappa per includere sia l'utente che il punto più vicino
                    const bounds = new mapboxgl.LngLatBounds();
                    bounds.extend(userLngLat);
                    bounds.extend(closestFeatureCoords);
                    map.fitBounds(bounds, { padding: 100, maxZoom: 16 });

                } else {
                    closestPointDetails.innerHTML = '<p>Nessun punto cestino/bidone trovato.</p>';
                    closestPointInfo.classList.remove('hidden');
                }
                locateMeButton.textContent = 'Trova la mia posizione';
                locateMeButton.disabled = false;
            },
            (error) => {
                console.error('Errore geolocalizzazione:', error);
                closestPointDetails.innerHTML = `<p class="text-red-500">Errore geolocalizzazione: ${error.message}. Assicurati di aver concesso i permessi.</p>`;
                closestPointInfo.classList.remove('hidden');
                locateMeButton.textContent = 'Trova la mia posizione';
                locateMeButton.disabled = false;
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
    } else {
        console.error('Geolocalizzazione non supportata dal browser.');
        closestPointDetails.innerHTML = '<p class="text-red-500">Il tuo browser non supporta la geolocalizzazione.</p>';
        closestPointInfo.classList.remove('hidden');
    }
});

getDirectionsButton.addEventListener('click', () => {
    if (userLngLat && closestFeatureCoords) {
        // Genera un URL per le indicazioni usando Mapbox
        const directionsUrl = `https://www.mapbox.com/directions/v5/mapbox/driving/${userLngLat[0]},${userLngLat[1]};${closestFeatureCoords[0]},${closestFeatureCoords[1]}?geometries=polyline&overview=full&steps=true&access_token=${mapboxgl.accessToken}`;
        window.open(directionsUrl, '_blank');
    } else {
        console.warn('Posizione utente o punto più vicino non disponibili per le indicazioni.');
        // Potresti voler mostrare un messaggio all'utente
    }
});


/**
 * Nasconde temporaneamente i controlli UI di Mapbox (zoom, bussola, attribuzione).
 */
function hideMapControls() {
    const controls = document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left');
    controls.forEach(control => {
        control.classList.add('mapboxgl-ctrl-hide-for-screenshot');
    });
}

/**
 * Ripristina la visibilità dei controlli UI di Mapbox.
 */
function showMapControls() {
    const controls = document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left');
    controls.forEach(control => {
        control.classList.remove('mapboxgl-ctrl-hide-for-screenshot');
    });
}

document.getElementById('screenshot-button').addEventListener('click', async () => {
    hideMapControls(); // Nascondi i controlli prima dello screenshot

    setTimeout(() => {
        html2canvas(document.getElementById('map'), {
            useCORS: true,
            allowTaint: true,
            backgroundColor: null // Mantiene lo sfondo trasparente se non c'è colore Mapbox
        }).then(canvas => {
            const link = document.createElement('a');
            link.download = 'mappa-cestini-screenshot.png'; // Nome file più generico
            link.href = canvas.toDataURL('image/png');
            link.click();

            showMapControls(); // Ripristina i controlli dopo lo screenshot
        }).catch(error => {
            console.error('Errore durante la cattura dello screenshot:', error);
            showMapControls(); // Assicurati di ripristinare i controlli anche in caso di errore
        });
    }, 100); // Breve ritardo per la renderizzazione del DOM dopo aver nascosto i controlli
});


// Logica per il menu mobile: apertura/chiusura con un tap/drag sul handle e click fuori
const sidebar = document.getElementById('sidebar');
const mobileSidebarHandle = document.getElementById('mobile-sidebar-handle');
const mapContainer = document.getElementById('map');

const MOBILE_BREAKPOINT = 768;
const COLLAPSED_HEIGHT_PX = 60; // Altezza del handle visibile quando collassato

let isDragging = false;
let startY = 0;
let initialTranslateY = 0; // La trasformazione Y al momento dell'inizio del drag

function isMobileView() {
    return window.innerWidth <= MOBILE_BREAKPOINT;
}

let clickOutsideListener = null;

function setMobileSidebarState(isOpen) {
    if (isOpen) {
        sidebar.classList.add('is-open');
        // Ho cambiato l'altezza della mappa a 20vh (100vh - 80vh della sidebar)
        mapContainer.style.height = `20vh`; 
        if (isMobileView() && !clickOutsideListener) {
            clickOutsideListener = (event) => {
                // Chiudi il menu solo se il click non è avvenuto sulla sidebar o sul handle
                if (!sidebar.contains(event.target) && event.target !== mobileSidebarHandle) {
                    setMobileSidebarState(false);
                }
            };
            document.addEventListener('click', clickOutsideListener);
        }
    } else {
        sidebar.classList.remove('is-open');
        mapContainer.style.height = `calc(100vh - ${COLLAPSED_HEIGHT_PX}px)`;
        if (clickOutsideListener) {
            document.removeEventListener('click', clickOutsideListener);
            clickOutsideListener = null;
        }
    }
    map.resize();
}

// Funzione per ottenere la trasformazione Y corrente della sidebar
function getSidebarCurrentTranslateY() {
    const transform = getComputedStyle(sidebar).transform;
    const matrix = new DOMMatrixReadOnly(transform);
    return matrix.m42; // m42 è il componente di traslazione Y
}


// Eventi per il trascinamento (drag) del menu mobile
if (mobileSidebarHandle) {
    mobileSidebarHandle.addEventListener('touchstart', (e) => {
        if (!isMobileView()) return;
        isDragging = true;
        startY = e.touches[0].clientY;
        initialTranslateY = getSidebarCurrentTranslateY();
        sidebar.style.transition = 'none'; // Disabilita la transizione durante il drag
        e.preventDefault(); // Impedisce lo scroll della pagina
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging || !isMobileView()) return;

        const currentTouchY = e.touches[0].clientY;
        let dy = currentTouchY - startY;
        let newTransformY = initialTranslateY + dy;

        // Limita il movimento: 0px (completamente aperto) a (altezza sidebar - altezza handle)
        const sidebarHeight = sidebar.offsetHeight;
        const maxTranslateY = sidebarHeight - COLLAPSED_HEIGHT_PX;

        newTransformY = Math.min(Math.max(0, newTransformY), maxTranslateY);
        sidebar.style.transform = `translateY(${newTransformY}px)`;
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
        if (!isDragging || !isMobileView()) return;
        isDragging = false;
        sidebar.style.transition = 'transform 0.3s ease-out'; // Riabilita la transizione

        const currentTranslateY = getSidebarCurrentTranslateY();
        const sidebarHeight = sidebar.offsetHeight;
        const maxTranslateY = sidebarHeight - COLLAPSED_HEIGHT_PX;

        // Determina se il menu deve aprirsi o chiudarsi in base alla posizione attuale
        // Se è più della metà strada verso l'alto, aprilo completamente
        if (currentTranslateY < maxTranslateY / 2) {
            setMobileSidebarState(true); // Scatta per aprire
        } else {
            setMobileSidebarState(false); // Scatta per chiudere
        }
    });

    // Anche il click semplice sull'handle deve aprire/chiudere il menu
    mobileSidebarHandle.addEventListener('click', (event) => {
        if (!isMobileView()) return;
        event.stopPropagation(); // Impedisce che il click attivi il listener di "click outside"
        const isOpen = sidebar.classList.contains('is-open');
        // Se si sta trascinando, il click non deve interferire (solo touchend gestirà)
        if (!isDragging) {
            setMobileSidebarState(!isOpen);
        }
    });
}


// Inizializza lo stato del menu mobile al caricamento della pagina se siamo su mobile
window.addEventListener('load', () => {
    if (isMobileView()) {
        setMobileSidebarState(false); // Assicurati che parta chiuso su mobile
    }
});

// Listener per il ridimensionamento della finestra per adattare il layout
window.addEventListener('resize', () => {
    if (!isMobileView()) {
        // Quando si ridimensiona in modalità desktop
        sidebar.classList.remove('is-open'); // Rimuovi la classe open del mobile
        sidebar.style.transform = ''; // Reset della trasformazione mobile
        mapContainer.style.height = '100%'; // Ripristina l'altezza completa della mappa
        if (clickOutsideListener) { // Rimuovi il listener se si passa a desktop
            document.removeEventListener('click', clickOutsideListener);
            clickOutsideListener = null;
        }
        map.resize(); // Ridimensiona la mappa dopo il cambio di layout
    } else {
        // Quando si ridimensiona in modalità mobile
        setMobileSidebarState(false); // Collassa il menu e regola l'altezza della mappa
    }
});
</script>
</body>
</html>
