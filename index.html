<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cestini</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* Stili Desktop (default) */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        #map {
            flex-grow: 1;
            height: 100%;
            width: 100%;
        }
        #sidebar {
            width: 320px;
            flex-shrink: 0;
            background: #ffffff;
            padding: 20px;
            overflow-y: auto;
            box-shadow: -2px 0 5px rgba(0,0,0,0.1);
            z-index: 10;
            display: flex;
            flex-direction: column;
        }

        /* Stili Popup Mapbox Moderni */
        .mapboxgl-popup {
            max-width: 300px;
        }
        .mapboxgl-popup-content {
            text-align: left;
            font-size: 15px;
            padding: 20px;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            border: none;
            background-color: #ffffff;
            position: relative;
        }
        .mapboxgl-popup-content h3 {
            margin: 0 0 10px 0;
            font-size: 1.2rem;
            font-weight: 700;
            color: #333;
            border-bottom: 1px solid #eee;
            padding-bottom: 10px;
        }
        .mapboxgl-popup-content p {
            margin: 0 0 8px 0;
            color: #555;
            line-height: 1.5;
        }
        .mapboxgl-popup-content p:last-of-type {
            margin-bottom: 0;
        }
        .mapboxgl-popup-close-button {
            top: 10px;
            right: 10px;
            font-size: 20px;
            color: #888;
            transition: color 0.2s;
        }
        .mapboxgl-popup-close-button:hover {
            color: #333;
        }

        .popup-link-button {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 15px;
            margin-top: 15px;
            background-color: #4f46e5;
            color: white;
            font-weight: 600;
            border-radius: 8px;
            text-decoration: none;
            transition: background-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            box-shadow: 0 2px 8px rgba(79, 70, 229, 0.3);
            gap: 8px;
        }
        .popup-link-button:hover {
            background-color: #4338ca;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.4);
        }
        .popup-link-button svg {
            width: 18px;
            height: 18px;
        }
        
        ::-webkit-scrollbar { display: none; }
        html, body { -ms-overflow-style: none; scrollbar-width: none; }

        /* Stili per nascondere temporaneamente i controlli Mapbox */
        .mapboxgl-ctrl-hide-for-screenshot { display: none !important; }

        /* --- Inizio Stili Mobile --- */
        @media (max-width: 768px) {
            body {
                flex-direction: column;
                position: relative;
            }

            #map {
                height: calc(100vh - 60px);
                transition: height 0.3s ease-out;
            }

            #sidebar {
                position: fixed;
                bottom: 0;
                left: 0;
                width: 100%;
                height: 85vh; /* Altezza massima della sidebar */
                max-height: 85vh;
                transform: translateY(calc(85vh - 60px)); /* Posizione iniziale collassata */
                box-shadow: 0 -4px 12px rgba(0,0,0,0.1);
                border-radius: 24px 24px 0 0;
                padding: 0;
                z-index: 1000;
                overflow: hidden; /* Il contenitore sidebar non scrolla, lo fanno i suoi figli */
                transition: transform 0.3s ease-out;
                background-color: #f8f9fa;
                display: flex;
                flex-direction: column;
            }

            #sidebar.is-open {
                transform: translateY(0);
            }

            /* Contenitore principale della sidebar mobile */
            #mobile-sidebar-container {
                display: flex;
                flex-direction: column;
                height: 100%; /* Permette ai figli di usare altezza basata su questa */
            }

            /* Intestazione con handle e titolo */
            #mobile-sidebar-header {
                padding: 12px 20px;
                text-align: center;
                flex-shrink: 0; /* Non si restringe */
                cursor: grab;
                touch-action: none;
            }
            
            #mobile-sidebar-header .handle {
                width: 40px;
                height: 4px;
                background-color: #ccc;
                border-radius: 2px;
                margin: 0 auto 8px;
            }

            #mobile-sidebar-header .title {
                font-size: 1.1rem;
                font-weight: 600;
                color: #333;
            }

            /* Navigazione a schede (Tabs) */
            #mobile-tabs {
                display: flex;
                justify-content: center;
                border-bottom: 1px solid #e5e7eb;
                flex-shrink: 0; /* Non si restringe */
                padding: 0 20px;
            }
            .tab-button {
                padding: 12px 16px;
                font-size: 0.9rem;
                font-weight: 500;
                color: #6b7280;
                border-bottom: 2px solid transparent;
                cursor: pointer;
                transition: all 0.2s ease-in-out;
            }
            .tab-button.active {
                color: #4f46e5;
                border-bottom-color: #4f46e5;
            }

            /* Contenuto delle schede: deve occupare lo spazio rimanente e essere scorrevole */
            .tab-content {
                display: none; /* Nascosto di default */
                flex-grow: 1; /* Occupano lo spazio rimanente */
                padding: 20px;
                flex-direction: column;
                background-color: #f8f9fa;
                overflow-y: hidden; /* Di default nascosto */
                /* max-height verr√† impostato via JS per calcolare lo spazio rimanente */
            }
            .tab-content.active {
                display: flex; /* Visibile quando attivo */
                overflow-y: auto; /* Attiva lo scorrimento per la tab attiva */
                -webkit-overflow-scrolling: touch; /* Migliora lo scorrimento su iOS */
            }

            /* Stile specifico per i filtri mobile - flex-grow per riempire lo spazio */
            #filters-mobile {
                flex-grow: 1; /* Permette ai filtri di occupare lo spazio disponibile */
                padding-right: 5px; /* Spazio per la scrollbar se visibile */
            }

            /* Stile specifico per i pulsanti di azione */
            #mobile-actions-grid {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 16px;
                margin-top: 24px;
                flex-shrink: 0; /* Impedisce ai pulsanti di restringersi */
            }
            .action-button {
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                padding: 16px 8px;
                background-color: #ffffff;
                border-radius: 12px;
                border: 1px solid #e5e7eb;
                text-align: center;
                font-size: 0.85rem;
                font-weight: 500;
                color: #374151;
                transition: all 0.2s ease-in-out;
                box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            }
            .action-button:hover {
                background-color: #f3f4f6;
                border-color: #d1d5db;
            }
            .action-button svg {
                width: 24px;
                height: 24px;
                margin-bottom: 8px;
                color: #4f46e5;
            }

            /* Nascondi la versione desktop nella vista mobile */
            #desktop-sidebar-content {
                display: none;
            }
        }

        /* --- Fine Stili Mobile --- */

        /* Nascondi la versione mobile nella vista desktop */
        @media (min-width: 769px) {
            #mobile-sidebar-container {
                display: none;
            }
        }
    </style>
</head>
<body>
<div id="sidebar">
    <!-- Contenuto per Desktop -->
    <div id="desktop-sidebar-content" class="flex flex-col flex-grow">
        <div class="p-4 md:p-0">
            <h1 class="text-2xl font-bold text-gray-800">Mappa Cestini</h1>
            <p class="text-sm text-gray-600">Filtra e interagisci con i punti sulla mappa.</p>
        </div>
        <div class="flex-grow">
            <div id="filter-container-desktop">
                <h2 class="text-lg font-semibold text-gray-700 my-3 border-b pb-2">Filtra per tipo</h2>
                <div id="filters-desktop" class="space-y-2"></div>
            </div>
            <div class="mt-8">
                <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">La tua posizione</h2>
                <button id="locate-me-button-desktop" class="w-full bg-indigo-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 shadow-md">Trova la mia posizione</button>
                <div id="closest-point-info-desktop" class="mt-4 p-4 bg-gray-100 rounded-lg shadow-sm hidden">
                    <h3 class="text-md font-bold text-gray-800 mb-2">Punto pi√π vicino:</h3>
                    <div id="closest-point-details-desktop" class="text-sm text-gray-700 space-y-1"></div>
                </div>
            </div>
        </div>
        <div class="space-y-3 mt-8">
            <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">Azioni</h2>
            <button id="center-button-desktop" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 shadow-md">Centra sui punti visibili</button>
            <button id="screenshot-button-desktop" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 shadow-md">Cattura Screenshot</button>
        </div>
    </div>

    <!-- Contenuto per Mobile -->
    <div id="mobile-sidebar-container">
        <div id="mobile-sidebar-header">
            <div class="handle"></div>
            <div class="title">Esplora la Mappa</div>
        </div>
        <div id="mobile-tabs">
            <button class="tab-button active" data-tab="cerca">Cerca</button>
            <button class="tab-button" data-tab="filtri">Filtri</button>
        </div>
        
        <!-- Contenuto Scheda Cerca -->
        <div id="tab-content-cerca" class="tab-content active">
            <h2 class="text-lg font-semibold text-gray-700 mb-4">Trova il punto pi√π vicino</h2>
            <button id="locate-me-button-mobile" class="w-full bg-indigo-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-indigo-700 transition duration-300 shadow-lg flex items-center justify-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>
                <span>Trova la mia posizione</span>
            </button>
            <div id="closest-point-info-mobile" class="mt-6 p-4 bg-white rounded-lg shadow-sm hidden border border-gray-200">
                <h3 class="text-md font-bold text-gray-800 mb-2">Punto pi√π vicino:</h3>
                <div id="closest-point-details-mobile" class="text-sm text-gray-700 space-y-1"></div>
            </div>
            <div id="mobile-actions-grid">
                <button id="center-button-mobile" class="action-button">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>
                    <span>Centra Mappa</span>
                </button>
                <button id="screenshot-button-mobile" class="action-button">
                     <!-- Icona corretta per lo screenshot (camera) -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>
                    <span>Screenshot</span>
                </button>
            </div>
        </div>

        <!-- Contenuto Scheda Filtri -->
        <div id="tab-content-filtri" class="tab-content">
             <h2 class="text-lg font-semibold text-gray-700 mb-3">Filtra per tipo</h2>
             <div id="filters-mobile" class="space-y-2"></div>
        </div>
    </div>
</div>
<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoicXdhbWR5IiwiYSI6ImNtZWNpajBvNTFqMGQybHF2d3NtemprNGUifQ.YVS-mtfbzisMPLhTO_dtAw';
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [10.5274, 42.92511],
    zoom: 13.89,
    preserveDrawingBuffer: true
});
map.addControl(new mapboxgl.NavigationControl());

const layerId = 'cestini-layer';
const bidoniVSquareLayerId = 'bidoni-v-square-layer';
const userLocationLayerId = 'user-location-layer';
const closestPointLayerId = 'closest-point-layer';

let fullGeojsonData = null;
let userLngLat = null;
let closestFeatureCoords = null;
let isLocationFound = false;

const squareSvgString = `<svg width="24" height="24" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><rect x="0" y="0" width="24" height="24" fill="currentColor"/></svg>`;
const squareImage = new Image(24, 24);
squareImage.src = 'data:image/svg+xml;base64,' + btoa(squareSvgString);

fetch('cestini.geojson')
    .then(res => res.json())
    .then(data => {
        fullGeojsonData = data;
        map.on('load', () => {
            map.addImage('square-icon', squareImage);
            map.addSource(layerId, { type: 'geojson', data });

            map.addLayer({
                id: layerId, type: 'circle', source: layerId,
                filter: ['!=', 'type', 'Bidoni-V'],
                paint: { 'circle-radius': 5, 'circle-color': ['to-color', ['get', 'colour']], 'circle-stroke-width': 1, 'circle-stroke-color': '#333' }
            });
            map.addLayer({
                id: bidoniVSquareLayerId, type: 'symbol', source: layerId,
                filter: ['==', 'type', 'Bidoni-V'],
                layout: { 'icon-image': 'square-icon', 'icon-size': 0.3, 'icon-allow-overlap': true, 'icon-anchor': 'center' },
                paint: { 'icon-color': ['to-color', ['get', 'colour']] }
            });
            map.addSource(userLocationLayerId, { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            map.addLayer({
                id: userLocationLayerId, type: 'circle', source: userLocationLayerId,
                paint: { 'circle-radius': 8, 'circle-color': '#007cbf', 'circle-stroke-width': 2, 'circle-stroke-color': '#ffffff' }
            });
            map.addSource(closestPointLayerId, { type: 'geojson', data: { type: 'FeatureCollection', features: [] } });
            map.addLayer({
                id: closestPointLayerId, type: 'circle', source: closestPointLayerId,
                paint: { 'circle-radius': 12, 'circle-color': '#ff0000', 'circle-stroke-width': 3, 'circle-stroke-color': '#ffffff', 'circle-opacity': 0.8 }
            });

            map.on('click', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], (e) => {
                const coords = e.features[0].geometry.coordinates.slice();
                const props = e.features[0].properties;
                const lat = coords[1];
                const lng = coords[0];
                const googleMapsLink = `https://www.google.com/maps/search/${lat},${lng}`;

                let html = `<h3 class="font-bold capitalize">${props.type || 'Dettagli'}</h3><div class="mt-2 space-y-1">`;
                for (const k in props) {
                    if (k === 'colour' || typeof props[k] === 'boolean' || k === 'isUserLocation' || k === 'isClosestPoint') continue;
                    html += `<p><strong>${k.charAt(0).toUpperCase() + k.slice(1)}:</strong> ${props[k]}</p>`;
                }
                html += `</div>
                        <a href="${googleMapsLink}" target="_blank" class="popup-link-button">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                            </svg>
                            <span>Google Maps</span>
                        </a>`;
                new mapboxgl.Popup().setLngLat(coords).setHTML(html).addTo(map);
            });

            map.on('mouseenter', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], () => { map.getCanvas().style.cursor = 'pointer'; });
            map.on('mouseleave', [layerId, bidoniVSquareLayerId, userLocationLayerId, closestPointLayerId], () => { map.getCanvas().style.cursor = ''; });

            generateFilters(data);
        });
    })
    .catch(err => {
        console.error('Errore caricamento GeoJSON:', err);
        document.getElementById('filters-desktop').innerHTML = '<p class="text-red-500">Errore caricamento dati.</p>';
        document.getElementById('filters-mobile').innerHTML = '<p class="text-red-500">Errore caricamento dati.</p>';
    });

function generateFilters(data) {
    const features = data.features;
    const types = new Set(features.map(f => f.properties?.type).filter(type => type != null));
    const desktopContainer = document.getElementById('filters-desktop');
    const mobileContainer = document.getElementById('filters-mobile');
    
    desktopContainer.innerHTML = '';
    mobileContainer.innerHTML = '';

    if (!types.size) {
        const errorMsg = '<p class="text-gray-500">Nessun attributo "type" trovato.</p>';
        desktopContainer.innerHTML = errorMsg;
        mobileContainer.innerHTML = errorMsg;
        return;
    }
    
    const sortedTypes = Array.from(types).sort();

    sortedTypes.forEach(type => {
        const id = `filter-${type.replace(/\s+/g, '-')}`;
        const createFilterElement = (idSuffix) => {
            const label = document.createElement('label');
            label.htmlFor = `${id}-${idSuffix}`;
            label.className = 'flex items-center space-x-3 p-2 rounded-md hover:bg-gray-200 cursor-pointer';
            const cb = document.createElement('input');
            cb.type = 'checkbox';
            cb.id = `${id}-${idSuffix}`;
            cb.value = type;
            cb.checked = true;
            cb.className = 'h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500';
            cb.addEventListener('change', () => {
                const counterpartSuffix = idSuffix === 'desktop' ? 'mobile' : 'desktop';
                const counterpartCheckbox = document.getElementById(`${id}-${counterpartSuffix}`);
                if (counterpartCheckbox) {
                    counterpartCheckbox.checked = cb.checked;
                }
                updateFilters();
            });
            const span = document.createElement('span');
            span.textContent = type.charAt(0).toUpperCase() + type.slice(1);
            span.className = 'text-gray-700';
            label.appendChild(cb);
            label.appendChild(span);
            return label;
        };
        desktopContainer.appendChild(createFilterElement('desktop'));
        mobileContainer.appendChild(createFilterElement('mobile'));
    });
}


function updateFilters() {
    const selector = '#filters-desktop input[type="checkbox"]';
    const checked = Array.from(document.querySelectorAll(selector))
        .filter(cb => cb.checked)
        .map(cb => cb.value);

    let circleFilter;
    if (!checked.length) {
        circleFilter = ['==', 'type', ''];
    } else {
        const filteredChecked = checked.filter(type => type !== 'Bidoni-V');
        if (filteredChecked.length > 0) {
            circleFilter = ['all', ['!=', 'type', 'Bidoni-V'], ['in', 'type', ...filteredChecked]];
        } else {
            circleFilter = ['==', 'type', ''];
        }
    }
    map.setFilter(layerId, circleFilter);

    let squareFilter;
    if (checked.includes('Bidoni-V')) {
        squareFilter = ['==', 'type', 'Bidoni-V'];
    } else {
        squareFilter = ['==', 'type', ''];
    }
    map.setFilter(bidoniVSquareLayerId, squareFilter);
}


function centerMapOnVisiblePoints() {
    const features = map.queryRenderedFeatures({ layers: [layerId, bidoniVSquareLayerId] });
    if (!features.length) { return; }
    const bounds = new mapboxgl.LngLatBounds();
    features.forEach(f => bounds.extend(f.geometry.coordinates));
    map.fitBounds(bounds, { padding: 80, maxZoom: 16 });
}

function captureScreenshot() {
    hideMapControls();
    setTimeout(() => {
        html2canvas(document.getElementById('map'), { useCORS: true, allowTaint: true, backgroundColor: null })
            .then(canvas => {
                const link = document.createElement('a');
                link.download = 'mappa-cestini-screenshot.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
                showMapControls();
            }).catch(error => {
                console.error('Errore screenshot:', error);
                showMapControls();
            });
    }, 100);
}

document.getElementById('center-button-desktop').addEventListener('click', centerMapOnVisiblePoints);
document.getElementById('center-button-mobile').addEventListener('click', centerMapOnVisiblePoints);
document.getElementById('screenshot-button-desktop').addEventListener('click', captureScreenshot);
document.getElementById('screenshot-button-mobile').addEventListener('click', captureScreenshot);

function getActiveFilterValues() {
    const selector = '#filters-desktop input[type="checkbox"]';
    return Array.from(document.querySelectorAll(selector))
        .filter(cb => cb.checked)
        .map(cb => cb.value);
}

function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371;
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
}

function findClosestPoint(userLng, userLat, activeFilters) {
    if (!fullGeojsonData || !fullGeojsonData.features.length) return null;
    
    const filteredFeatures = fullGeojsonData.features.filter(feature => 
        activeFilters.includes(feature.properties.type)
    );

    if (filteredFeatures.length === 0) {
        return null; // Nessun punto corrisponde ai filtri
    }

    let closest = null;
    let minDistance = Infinity;
    filteredFeatures.forEach(feature => {
        const coords = feature.geometry.coordinates;
        const distance = calculateDistance(userLat, userLng, coords[1], coords[0]);
        if (distance < minDistance) {
            minDistance = distance;
            closest = feature;
        }
    });
    return closest ? { feature: closest, distance: minDistance } : null;
}

function handleLocateMe() {
    const locateMeButtonDesktop = document.getElementById('locate-me-button-desktop');
    const locateMeButtonMobile = document.getElementById('locate-me-button-mobile').querySelector('span');
    const closestPointInfoDesktop = document.getElementById('closest-point-info-desktop');
    const closestPointDetailsDesktop = document.getElementById('closest-point-details-desktop');
    const closestPointInfoMobile = document.getElementById('closest-point-info-mobile');
    const closestPointDetailsMobile = document.getElementById('closest-point-details-mobile');

    if (isLocationFound) {
        locateMeButtonDesktop.textContent = 'Trova la mia posizione';
        locateMeButtonMobile.textContent = 'Trova la mia posizione';
        isLocationFound = false;
        closestPointInfoDesktop.classList.add('hidden');
        closestPointInfoMobile.classList.add('hidden');
        map.getSource(userLocationLayerId).setData({ type: 'FeatureCollection', features: [] });
        map.getSource(closestPointLayerId).setData({ type: 'FeatureCollection', features: [] });
        userLngLat = null;
        closestFeatureCoords = null;
        return;
    }

    if (navigator.geolocation) {
        locateMeButtonDesktop.textContent = 'Ricerca...';
        locateMeButtonMobile.textContent = 'Ricerca...';
        locateMeButtonDesktop.disabled = true;
        document.getElementById('locate-me-button-mobile').disabled = true;

        navigator.geolocation.getCurrentPosition(
            (position) => {
                const { latitude, longitude } = position.coords;
                userLngLat = [longitude, latitude];
                map.getSource(userLocationLayerId).setData({ type: 'FeatureCollection', features: [{ type: 'Feature', geometry: { type: 'Point', coordinates: userLngLat }, properties: { description: 'La tua posizione', isUserLocation: true } }] });
                map.flyTo({ center: userLngLat, zoom: 15 });

                const activeFilters = getActiveFilterValues();
                const result = findClosestPoint(longitude, latitude, activeFilters);
                
                let detailsHtml;
                if (result) {
                    const { feature, distance } = result;
                    closestFeatureCoords = feature.geometry.coordinates;
                    const lat = closestFeatureCoords[1];
                    const lng = closestFeatureCoords[0];
                    const googleMapsLink = `https://www.google.com/maps/search/${lat},${lng}`;

                    detailsHtml = `<p><strong>Tipo:</strong> ${feature.properties.type || 'N/A'}</p><p><strong>Distanza:</strong> ${distance.toFixed(2)} km</p>`;
                    if (feature.properties.name) detailsHtml += `<p><strong>Nome:</strong> ${feature.properties.name}</p>`;
                    detailsHtml += `<a href="${googleMapsLink}" target="_blank" class="popup-link-button mt-4">
                                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 16.657L13.414 20.9a1.998 1.998 0 01-2.827 0l-4.244-4.243a8 8 0 1111.314 0z"/>
                                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 11a3 3 0 11-6 0 3 3 0 016 0z"/>
                                        </svg>
                                        <span>Google Maps</span>
                                    </a>`;

                    map.getSource(closestPointLayerId).setData({ type: 'FeatureCollection', features: [{ type: 'Feature', geometry: { type: 'Point', coordinates: closestFeatureCoords }, properties: { description: 'Punto pi√π vicino', isClosestPoint: true, ...feature.properties } }] });
                    const bounds = new mapboxgl.LngLatBounds();
                    bounds.extend(userLngLat);
                    bounds.extend(closestFeatureCoords);
                    map.fitBounds(bounds, { padding: 100, maxZoom: 16 });
                } else {
                    detailsHtml = '<p>Nessun punto trovato con i filtri attuali.</p>';
                     map.getSource(closestPointLayerId).setData({ type: 'FeatureCollection', features: [] });
                }
                
                closestPointDetailsDesktop.innerHTML = detailsHtml;
                closestPointInfoDesktop.classList.remove('hidden');
                closestPointDetailsMobile.innerHTML = detailsHtml;
                closestPointInfoMobile.classList.remove('hidden');

                locateMeButtonDesktop.textContent = 'Trovane un altro';
                locateMeButtonMobile.textContent = 'Trovane un altro';
                isLocationFound = true;
            },
            (error) => {
                console.error('Errore geolocalizzazione:', error);
                const errorHtml = `<p class="text-red-500">Errore: ${error.message}.</p>`;
                closestPointDetailsDesktop.innerHTML = errorHtml;
                closestPointInfoDesktop.classList.remove('hidden');
                closestPointDetailsMobile.innerHTML = errorHtml;
                closestPointInfoMobile.classList.remove('hidden');
                locateMeButtonDesktop.textContent = 'Trova la mia posizione';
                locateMeButtonMobile.textContent = 'Trova la mia posizione';
                isLocationFound = false;
            },
            { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 }
        );
    } else {
        const errorHtml = '<p class="text-red-500">Geolocalizzazione non supportata.</p>';
        closestPointDetailsDesktop.innerHTML = errorHtml;
        closestPointInfoDesktop.classList.remove('hidden');
        closestPointDetailsMobile.innerHTML = errorHtml;
        closestPointInfoMobile.classList.remove('hidden');
    }
    locateMeButtonDesktop.disabled = false;
    document.getElementById('locate-me-button-mobile').disabled = false;
}

document.getElementById('locate-me-button-desktop').addEventListener('click', handleLocateMe);
document.getElementById('locate-me-button-mobile').addEventListener('click', handleLocateMe);

function hideMapControls() {
    document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left').forEach(c => c.classList.add('mapboxgl-ctrl-hide-for-screenshot'));
}

function showMapControls() {
    document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left').forEach(c => c.classList.remove('mapboxgl-ctrl-hide-for-screenshot'));
}

// Logica per il menu mobile
const sidebar = document.getElementById('sidebar');
const mobileSidebarHeader = document.getElementById('mobile-sidebar-header');
const mapContainer = document.getElementById('map');
const MOBILE_BREAKPOINT = 768;
const COLLAPSED_HEIGHT_PX = 60; // Altezza della sidebar quando √® chiusa/collassata
let isDragging = false, startY = 0, initialTranslateY = 0;

function isMobileView() { return window.innerWidth <= MOBILE_BREAKPOINT; }

function setMobileSidebarState(isOpen) {
    if (isOpen) {
        sidebar.classList.add('is-open');
        mapContainer.style.height = `15vh`; // Mappa pi√π piccola quando il menu √® aperto
    } else {
        sidebar.classList.remove('is-open');
        mapContainer.style.height = `calc(100vh - ${COLLAPSED_HEIGHT_PX}px)`; // Mappa pi√π grande quando il menu √® chiuso
    }
    map.resize();
    updateTabContentScrollability(); // Chiamata per aggiornare la scorrevolezza dei contenuti
}

function getSidebarCurrentTranslateY() {
    const transform = getComputedStyle(sidebar).transform;
    // La matrice 2D ha il valore di traslazione Y in m42 (indice 5 dell'array FlatArray)
    return parseFloat(new DOMMatrixReadOnly(transform).m42);
}

// Funzione per aggiornare la scorrevolezza dei contenuti delle tab
function updateTabContentScrollability() {
    if (!isMobileView()) {
        // Reset per desktop
        document.querySelectorAll('.tab-content').forEach(content => {
            content.style.maxHeight = '';
            content.style.overflowY = 'hidden';
        });
        document.getElementById('filters-mobile').style.overflowY = 'hidden';
        return;
    }

    // Calcola l'altezza disponibile per i contenuti scorrevoli
    // Sottrai l'altezza dell'header e della navigazione a schede
    const sidebarHeight = sidebar.clientHeight;
    const headerHeight = mobileSidebarHeader.offsetHeight;
    const tabsHeight = document.getElementById('mobile-tabs').offsetHeight;
    const availableHeight = sidebarHeight - headerHeight - tabsHeight - 40; // 40px di padding extra

    document.querySelectorAll('.tab-content').forEach(content => {
        if (content.classList.contains('active')) {
            content.style.maxHeight = `${availableHeight}px`;
            content.style.overflowY = 'auto';
            // Assicurati che anche filters-mobile possa scrollare se √® nella tab attiva
            if (content.id === 'tab-content-filtri') {
                 // Potrebbe essere necessario applicare max-height e overflow-y anche qui se filters-mobile non √® flex-grow
                 // Nel CSS attuale, filters-mobile ha flex-grow: 1, quindi dovrebbe ereditare lo scorrimento dal suo genitore .tab-content.active
                 // Se non scrolla, potresti voler impostare un'altezza fissa o max-height qui.
                 // Per ora, ci affidiamo a flex-grow e overflow-y: auto sul genitore.
            }
        } else {
            content.style.maxHeight = ''; // Rimuovi max-height per le tab non attive
            content.style.overflowY = 'hidden';
        }
    });
}


if (mobileSidebarHeader) {
    mobileSidebarHeader.addEventListener('touchstart', (e) => {
        if (!isMobileView()) return;
        isDragging = true;
        startY = e.touches[0].clientY;
        initialTranslateY = getSidebarCurrentTranslateY();
        sidebar.style.transition = 'none';
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging || !isMobileView()) return;
        const currentTouchY = e.touches[0].clientY;
        let dy = currentTouchY - startY;
        let newTransformY = initialTranslateY + dy;
        const maxTranslateY = sidebar.offsetHeight - COLLAPSED_HEIGHT_PX;
        newTransformY = Math.min(Math.max(0, newTransformY), maxTranslateY);
        sidebar.style.transform = `translateY(${newTransformY}px)`;
        
        // Aggiorna lo scrollability durante il trascinamento per mostrare che il contenuto pu√≤ scorrere
        updateTabContentScrollability(); 
        
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
        if (!isDragging || !isMobileView()) return;
        isDragging = false;
        sidebar.style.transition = 'transform 0.3s ease-out';
        const currentTranslateY = getSidebarCurrentTranslateY();
        const maxTranslateY = sidebar.offsetHeight - COLLAPSED_HEIGHT_PX;

        // Determina se la sidebar deve essere completamente aperta o collassata
        // La soglia √® un terzo dell'altezza tra la posizione aperta e quella collassata
        const openThreshold = maxTranslateY / 3; 

        if (currentTranslateY < openThreshold) {
            // Se trascinato abbastanza in alto, apri completamente
            setMobileSidebarState(true);
        } else {
            // Altrimenti, torna alla posizione collassata
            setMobileSidebarState(false);
        }
        updateTabContentScrollability(); // Aggiorna dopo il rilascio
    });

    mobileSidebarHeader.addEventListener('click', (event) => {
        if (!isMobileView()) return; // Non bloccare il click se non √® mobile
        // Previeni l'evento click dopo un trascinamento, altrimenti potrebbe innescare un toggle non desiderato
        if (isDragging) {
            isDragging = false; // Reset per il prossimo evento
            return;
        }
        const isOpen = sidebar.classList.contains('is-open');
        setMobileSidebarState(!isOpen);
        updateTabContentScrollability(); // Aggiorna dopo il click
    });
}


// Gestione Tabs Mobile
document.querySelectorAll('.tab-button').forEach(button => {
    button.addEventListener('click', () => {
        const tab = button.dataset.tab;
        document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
        button.classList.add('active');
        document.querySelectorAll('.tab-content').forEach(content => {
            content.classList.remove('active');
            if (content.id === `tab-content-${tab}`) {
                content.classList.add('active');
            }
        });
        updateTabContentScrollability(); // Chiamata per aggiornare la scorrevolezza dei contenuti al cambio di tab
    });
});

window.addEventListener('load', () => { 
    if (isMobileView()) {
        setMobileSidebarState(false);
        updateTabContentScrollability(); // Chiamata iniziale al caricamento
    }
});
window.addEventListener('resize', () => {
    if (!isMobileView()) {
        sidebar.classList.remove('is-open');
        sidebar.style.transform = '';
        mapContainer.style.height = '100%';
        map.resize();
        // Reset scrollability per desktop
        document.querySelectorAll('.tab-content').forEach(content => {
            content.style.maxHeight = '';
            content.style.overflowY = 'hidden';
        });
        document.getElementById('filters-mobile').style.overflowY = 'hidden'; // Anche qui reset
    } else {
        // Quando la sidebar √® completamente chiusa (nella posizione collassata), anche la mappa √® grande
        const currentTranslateY = getSidebarCurrentTranslateY();
        const maxTranslateY = sidebar.offsetHeight - COLLAPSED_HEIGHT_PX;
        if (currentTranslateY >= maxTranslateY - 5) { // Tolleranza per il float
            mapContainer.style.height = `calc(100vh - ${COLLAPSED_HEIGHT_PX}px)`;
            sidebar.style.transform = `translateY(${maxTranslateY}px)`; // Assicura che sia ben collassata
        } else if (currentTranslateY <= 5) { // Tolleranza per il float (completamente aperta)
            mapContainer.style.height = `15vh`;
            sidebar.style.transform = `translateY(0px)`; // Assicura che sia ben aperta
        } else {
            // Se si trova in uno stato intermedio, mantieni l'altezza della mappa in base allo stato attuale
            // o ripristina a una delle due posizioni principali.
            // Per semplicit√†, la rimettiamo nello stato collassato in caso di resize in stato intermedio.
            mapContainer.style.height = `calc(100vh - ${COLLAPSED_HEIGHT_PX}px)`;
            sidebar.style.transform = `translateY(${maxTranslateY}px)`;
        }
        map.resize();
        updateTabContentScrollability(); // Chiamata al ridimensionamento
    }
});
</script>
</body>
</html>
