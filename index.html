<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mappa Interattiva Cestini</title>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        /* Stili Desktop (default) */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            display: flex; /* La sidebar è a destra della mappa */
            height: 100vh;
            overflow: hidden; /* Evita lo scroll indesiderato */
            -webkit-user-select: none; /* Chrome, Safari, Opera */
            -moz-user-select: none;    /* Firefox */
            -ms-user-select: none;     /* Internet Explorer / Edge legacy */
            user-select: none;         /* Standard */
        }
        #map {
            flex-grow: 1; /* La mappa occupa tutto lo spazio disponibile */
            height: 100%;
            width: 100%; /* Inizialmente occupa tutta la larghezza rimanente */
        }
        #sidebar {
            width: 320px; /* Larghezza fissa per desktop */
            flex-shrink: 0; /* Impedisce che la sidebar si restringa */
            background: #f8f9fa;
            padding: 20px; /* Padding originale per desktop */
            overflow-y: auto; /* Permette lo scroll del contenuto se in eccesso */
            box-shadow: -2px 0 5px rgba(0,0,0,0.1); /* Ombra a sinistra */
            z-index: 10;
            border-radius: 12px 0 0 12px; /* Angoli arrotondati in alto a destra per desktop */
            transition: all 0.3s ease-out; /* Transizione per proprietà che potrebbero cambiare */
            display: flex; /* Per layout interno della sidebar */
            flex-direction: column;
        }

        /* Stili Popup Mapbox (rimangono uguali) */
        .mapboxgl-popup { max-width: 250px; }
        .mapboxgl-popup-content { text-align: left; font-size: 14px; padding: 15px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.15); }
        .mapboxgl-popup-content h3 { margin: 0 0 5px 0; font-size: 16px; color: #333; }
        .mapboxgl-popup-content p { margin: 0; }

        /* Overrides specifici per Mobile */
        @media (max-width: 768px) {
            body {
                flex-direction: column; /* Impila mappa e sidebar verticalmente */
                position: relative; /* Per posizionamento fisso della sidebar */
            }

            #map {
                /* Altezza iniziale della mappa per lasciare spazio al handle del menu (60px) */
                height: calc(100vh - 60px);
                transition: height 0.3s ease-out; /* Transizione fluida per l'altezza della mappa */
            }

            #sidebar {
                position: fixed; /* Posizione fissa in basso */
                bottom: 0;
                left: 0;
                width: 100%; /* Larghezza piena per mobile */
                height: 80vh; /* Altezza massima quando completamente aperto (80% del viewport) */
                max-height: 80vh; /* Assicura che non superi questa altezza */
                transform: translateY(calc(80vh - 60px)); /* Nascondi inizialmente la maggior parte, lascia 60px visibili */
                box-shadow: 0 -2px 10px rgba(0,0,0,0.15); /* Ombra in alto per separare dalla mappa */
                border-radius: 12px 12px 0 0; /* Angoli arrotondati in alto per mobile */
                padding: 0; /* Padding gestito internamente per mobile */
                z-index: 1000; /* Assicura che sia sopra gli altri elementi */
                overflow: hidden; /* Nasconde lo scrollbar quando è collassato */
                transition: transform 0.3s ease-out; /* Transizione per l'apertura/chiusura */
            }

            #sidebar.is-open {
                transform: translateY(0); /* Completamente aperto */
                box-shadow: 0 -2px 10px rgba(0,0,0,0.25); /* Ombra leggermente più pronunciata quando aperto */
            }

            #mobile-sidebar-handle {
                width: 100%;
                height: 60px; /* Altezza visibile del handle quando il menu è chiuso */
                background-color: #f8f9fa;
                border-radius: 12px 12px 0 0;
                display: flex;
                flex-direction: column;
                justify-content: center;
                align-items: center;
                flex-shrink: 0; /* Impedisce che si riduca */
                position: relative;
                z-index: 1001; /* Assicurati che sia sopra il contenuto scorrevole */
                cursor: grab; /* Indica che è trascinabile */
                touch-action: none; /* Previene azioni touch predefinite del browser */
            }

            #mobile-sidebar-handle::before {
                content: '';
                width: 40px;
                height: 4px;
                background-color: #ccc;
                border-radius: 2px;
            }

            /* Nasconde il contenuto scorrevole quando la sidebar non è aperta */
            #sidebar-scrollable-content {
                flex-grow: 1;
                overflow-y: hidden; /* Nasconde lo scrollbar quando chiuso */
                padding: 0 15px 15px 15px; /* Applica padding al contenuto scorrevole per mobile */
                opacity: 0;
                visibility: hidden;
                max-height: 0; /* Collassa il contenuto */
                transition: opacity 0.3s ease-out, visibility 0.3s ease-out, max-height 0.3s ease-out;
            }

            /* Mostra e abilita lo scroll del contenuto quando la sidebar è aperta */
            #sidebar.is-open #sidebar-scrollable-content {
                overflow-y: auto; /* Abilita lo scrollbar quando aperto */
                opacity: 1;
                visibility: visible;
                max-height: 100vh; /* Permette al contenuto di assumere l'altezza naturale (o quasi) per scroll fluido */
            }
        }

        /* Nasconde il handle e assicura visibilità del contenuto su desktop */
        @media (min-width: 769px) {
            #mobile-sidebar-handle {
                display: none; /* Nasconde il handle su desktop */
            }
            #sidebar-scrollable-content {
                opacity: 1;
                visibility: visible;
                max-height: none; /* Reset per desktop */
                overflow-y: auto; /* Abilita scrollbar per desktop */
                padding: 0; /* Reset padding specifico per mobile dal contenuto su desktop */
            }
        }

        /* Stili per nascondere temporaneamente i controlli Mapbox */
        .mapboxgl-ctrl-hide-for-screenshot {
            display: none !important;
        }
    </style>
</head>
<body>
<div id="sidebar">
    <!-- Handle per mobile (visibile solo su mobile) -->
    <div id="mobile-sidebar-handle"></div>

    <!-- Il contenuto della sidebar è ora avvolto in un div scorrevole.
         Le classi flex-col e space-y-6 vengono applicate qui per il layout interno
         che deve essere flessibile sia su mobile che su desktop. -->
    <div id="sidebar-scrollable-content" class="flex flex-col space-y-6">
        <div>
            <h1 class="text-2xl font-bold text-gray-800">Mappa Cestini</h1>
            <p class="text-sm text-gray-600">Filtra e interagisci con i punti sulla mappa.</p>
        </div>
        <div id="filter-container" class="flex-grow">
            <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">Filtra per tipo</h2>
            <div id="filters" class="space-y-2"><div class="text-center text-gray-500 p-4"><p>Caricamento filtri...</p></div></div>
        </div>
        <div class="space-y-3">
            <h2 class="text-lg font-semibold text-gray-700 mb-3 border-b pb-2">Azioni</h2>
            <button id="center-button" class="w-full bg-blue-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-700 transition duration-300 shadow-md">Centra sui punti visibili</button>
            <button id="screenshot-button" class="w-full bg-green-600 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-700 transition duration-300 shadow-md">Cattura Screenshot</button>
        </div>
    </div>
</div>
<div id="map"></div>

<script>
mapboxgl.accessToken = 'pk.eyJ1IjoicXdhbWR5IiwiYSI6ImNtZWNpajBvNTFqMGQybHF2d3NtemprNGUifQ.YVS-mtfbzisMPLhTO_dtAw';
const map = new mapboxgl.Map({
    container: 'map',
    style: 'mapbox://styles/mapbox/streets-v12',
    center: [10.5274, 42.92511],
    zoom: 13.89,
    preserveDrawingBuffer: true
});
map.addControl(new mapboxgl.NavigationControl());

const layerId = 'cestini-layer';

// Variabile globale per memorizzare i dati GeoJSON completi
let fullGeojsonData = null;
let lastMapState = { center: map.getCenter(), zoom: map.getZoom() }; // Per memorizzare l'ultimo stato della mappa

// Carica il GeoJSON
fetch('cestini.geojson')
    .then(res => res.json())
    .then(data => {
        fullGeojsonData = data; // Memorizza i dati completi globalmente
        map.on('load', () => {
            map.addSource(layerId, { type: 'geojson', data });

            map.addLayer({
                id: layerId,
                type: 'circle',
                source: layerId,
                paint: {
                    'circle-radius': 5, // punti più piccoli
                    'circle-color': [
                        'to-color',
                        ['get', 'colour'] // prende il valore dalla proprietà "colour"
                    ],
                    'circle-stroke-width': 1,
                    'circle-stroke-color': '#333'
                }
            });

            // Popup su click
            map.on('click', layerId, (e) => {
                const coords = e.features[0].geometry.coordinates.slice();
                const props = e.features[0].properties;
                let html = `<h3 class="font-bold capitalize">${props.type || 'Dettagli'}</h3><div class="mt-2 space-y-1">`;
                for (const k in props) {
                    // Salta la proprietà 'colour' e i valori booleani, se non necessari nel popup
                    if (k === 'colour' || typeof props[k] === 'boolean') continue;
                    html += `<p><strong>${k.charAt(0).toUpperCase() + k.slice(1)}:</strong> ${props[k]}</p>`;
                }
                html += '</div>';
                new mapboxgl.Popup().setLngLat(coords).setHTML(html).addTo(map);
            });

            map.on('mouseenter', layerId, () => { map.getCanvas().style.cursor = 'pointer'; });
            map.on('mouseleave', layerId, () => { map.getCanvas().style.cursor = ''; });

            generateFilters(data);
        });
    })
    .catch(err => {
        console.error('Errore caricamento GeoJSON:', err);
        document.getElementById('filters').innerHTML = '<p class="text-red-500">Errore caricamento dati.</p>';
    });

function generateFilters(data) {
    const features = data.features;
    // Filtra i tipi non definiti o null prima di creare il Set
    const types = new Set(features.map(f => f.properties?.type).filter(type => type != null));
    const container = document.getElementById('filters');
    container.innerHTML = '';
    if (!types.size) {
        container.innerHTML = '<p class="text-gray-500">Nessun attributo "type" trovato.</p>';
        return;
    }
    Array.from(types).sort().forEach(type => {
        const id = `filter-${type.replace(/\s+/g, '-')}`;
        const label = document.createElement('label');
        label.htmlFor = id;
        label.className = 'flex items-center space-x-3 p-2 rounded-md hover:bg-gray-200 cursor-pointer';

        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.id = id;
        cb.value = type;
        cb.checked = true;
        cb.className = 'h-4 w-4 rounded border-gray-300 text-blue-600 focus:ring-blue-500';
        cb.addEventListener('change', updateFilters);

        const span = document.createElement('span');
        span.textContent = type.charAt(0).toUpperCase() + type.slice(1);
        span.className = 'text-gray-700';

        label.appendChild(cb);
        label.appendChild(span);
        container.appendChild(label);
    });
}

function updateFilters() {
    const checked = Array.from(document.querySelectorAll('#filters input[type="checkbox"]'))
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    if (!checked.length) {
        // Se nessun filtro è selezionato, nascondi tutti i punti impostando un filtro che non corrisponde a nulla
        map.setFilter(layerId, ['==', 'type', '']);
        return;
    }
    // Imposta il filtro per mostrare solo i tipi selezionati
    map.setFilter(layerId, ['in', 'type', ...checked]);
}

document.getElementById('center-button').addEventListener('click', () => {
    const features = map.queryRenderedFeatures({ layers: [layerId] });
    if (!features.length) { return; } // Non mostra più un messaggio
    const bounds = new mapboxgl.LngLatBounds();
    features.forEach(f => bounds.extend(f.geometry.coordinates));
    map.fitBounds(bounds, { padding: 80, maxZoom: 16 });
});

/**
 * Nasconde temporaneamente i controlli UI di Mapbox (zoom, bussola, attribuzione).
 */
function hideMapControls() {
    const controls = document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left');
    controls.forEach(control => {
        control.classList.add('mapboxgl-ctrl-hide-for-screenshot');
    });
}

/**
 * Ripristina la visibilità dei controlli UI di Mapbox.
 */
function showMapControls() {
    const controls = document.querySelectorAll('.mapboxgl-ctrl, .mapboxgl-canvas-container .mapboxgl-ctrl-bottom-left');
    controls.forEach(control => {
        control.classList.remove('mapboxgl-ctrl-hide-for-screenshot');
    });
}

document.getElementById('screenshot-button').addEventListener('click', async () => {
    if (!fullGeojsonData) {
        return; // Non mostra più un messaggio
    }

    // Salva lo stato attuale della mappa
    lastMapState = { center: map.getCenter(), zoom: map.getZoom() };

    let featuresToScreenshot = [];
    const activeFilter = map.getFilter(layerId); // Ottieni il filtro attualmente applicato

    if (activeFilter) {
        if (activeFilter[0] === 'in' && activeFilter[1] === 'type') {
            const allowedTypes = new Set(activeFilter.slice(2));
            featuresToScreenshot = fullGeojsonData.features.filter(f => allowedTypes.has(f.properties?.type));
        } else if (activeFilter[0] === '==' && activeFilter[1] === 'type' && activeFilter[2] === '') {
            featuresToScreenshot = []; // Esplicitamente filtrato per non mostrare nulla
        } else {
             featuresToScreenshot = [];
        }
    } else {
        featuresToScreenshot = fullGeojsonData.features;
    }

    if (!featuresToScreenshot.length) {
        map.flyTo({ center: lastMapState.center, zoom: lastMapState.zoom, duration: 0 });
        return;
    }

    const bounds = new mapboxgl.LngLatBounds();
    featuresToScreenshot.forEach(f => {
        if (f.geometry && f.geometry.coordinates && Array.isArray(f.geometry.coordinates) && f.geometry.coordinates.length >= 2) {
            bounds.extend(f.geometry.coordinates);
        }
    });

    if (bounds.isEmpty()) {
        map.flyTo({ center: lastMapState.center, zoom: lastMapState.zoom, duration: 0 });
        return;
    }

    map.fitBounds(bounds, { padding: 80, maxZoom: 16 });

    map.once('idle', () => {
        hideMapControls();

        setTimeout(() => {
            html2canvas(document.getElementById('map'), {
                useCORS: true,
                allowTaint: true,
                backgroundColor: null
            }).then(canvas => {
                const link = document.createElement('a');
                link.download = 'mappa-cestini-filtrata.png';
                link.href = canvas.toDataURL('image/png');
                link.click();

                showMapControls();
                map.flyTo({ center: lastMapState.center, zoom: lastMapState.zoom, duration: 0 });
            }).catch(error => {
                console.error('Errore durante la cattura dello screenshot:', error);
                showMapControls();
                map.flyTo({ center: lastMapState.center, zoom: lastMapState.zoom, duration: 0 });
            });
        }, 100); // Breve ritardo
    });
});

// Logica per il menu mobile: apertura/chiusura con un tap/drag sul handle e click fuori
const sidebar = document.getElementById('sidebar');
const mobileSidebarHandle = document.getElementById('mobile-sidebar-handle');
const mapContainer = document.getElementById('map');

const MOBILE_BREAKPOINT = 768;
const COLLAPSED_HEIGHT_PX = 60; // Altezza del handle visibile quando collassato

let isDragging = false;
let startY = 0;
let initialTranslateY = 0; // La trasformazione Y al momento dell'inizio del drag

function isMobileView() {
    return window.innerWidth <= MOBILE_BREAKPOINT;
}

let clickOutsideListener = null;

function setMobileSidebarState(isOpen) {
    if (isOpen) {
        sidebar.classList.add('is-open');
        mapContainer.style.height = `calc(100vh - 80vh)`; // La mappa occupa 20vh
        if (isMobileView() && !clickOutsideListener) {
            clickOutsideListener = (event) => {
                // Chiudi il menu solo se il click non è avvenuto sulla sidebar o sul handle
                if (!sidebar.contains(event.target) && event.target !== mobileSidebarHandle) {
                    setMobileSidebarState(false);
                }
            };
            document.addEventListener('click', clickOutsideListener);
        }
    } else {
        sidebar.classList.remove('is-open');
        mapContainer.style.height = `calc(100vh - ${COLLAPSED_HEIGHT_PX}px)`;
        if (clickOutsideListener) {
            document.removeEventListener('click', clickOutsideListener);
            clickOutsideListener = null;
        }
    }
    map.resize();
}

// Funzione per ottenere la trasformazione Y corrente della sidebar
function getSidebarCurrentTranslateY() {
    const transform = getComputedStyle(sidebar).transform;
    const matrix = new DOMMatrixReadOnly(transform);
    return matrix.m42; // m42 è il componente di traslazione Y
}


// Eventi per il trascinamento (drag) del menu mobile
if (mobileSidebarHandle) {
    mobileSidebarHandle.addEventListener('touchstart', (e) => {
        if (!isMobileView()) return;
        isDragging = true;
        startY = e.touches[0].clientY;
        initialTranslateY = getSidebarCurrentTranslateY();
        sidebar.style.transition = 'none'; // Disabilita la transizione durante il drag
        e.preventDefault(); // Impedisce lo scroll della pagina
    }, { passive: false });

    document.addEventListener('touchmove', (e) => {
        if (!isDragging || !isMobileView()) return;

        const currentTouchY = e.touches[0].clientY;
        let dy = currentTouchY - startY;
        let newTransformY = initialTranslateY + dy;

        // Limita il movimento: 0px (completamente aperto) a (altezza sidebar - altezza handle)
        const sidebarHeight = sidebar.offsetHeight;
        const maxTranslateY = sidebarHeight - COLLAPSED_HEIGHT_PX;

        newTransformY = Math.min(Math.max(0, newTransformY), maxTranslateY);
        sidebar.style.transform = `translateY(${newTransformY}px)`;
        e.preventDefault();
    }, { passive: false });

    document.addEventListener('touchend', () => {
        if (!isDragging || !isMobileView()) return;
        isDragging = false;
        sidebar.style.transition = 'transform 0.3s ease-out'; // Riabilita la transizione

        const currentTranslateY = getSidebarCurrentTranslateY();
        const sidebarHeight = sidebar.offsetHeight;
        const maxTranslateY = sidebarHeight - COLLAPSED_HEIGHT_PX;

        // Determina se il menu deve aprirsi o chiudersi in base alla posizione attuale
        // Se è più della metà strada verso l'alto, aprilo completamente
        if (currentTranslateY < maxTranslateY / 2) {
            setMobileSidebarState(true); // Scatta per aprire
        } else {
            setMobileSidebarState(false); // Scatta per chiudere
        }
    });

    // Anche il click semplice sull'handle deve aprire/chiudere il menu
    mobileSidebarHandle.addEventListener('click', (event) => {
        if (!isMobileView()) return;
        event.stopPropagation(); // Impedisce che il click attivi il listener di "click outside"
        const isOpen = sidebar.classList.contains('is-open');
        // Se si sta trascinando, il click non deve interferire (solo touchend gestirà)
        if (!isDragging) {
            setMobileSidebarState(!isOpen);
        }
    });
}


// Inizializza lo stato del menu mobile al caricamento della pagina se siamo su mobile
window.addEventListener('load', () => {
    if (isMobileView()) {
        setMobileSidebarState(false); // Assicurati che parta chiuso su mobile
    }
});

// Listener per il ridimensionamento della finestra per adattare il layout
window.addEventListener('resize', () => {
    if (!isMobileView()) {
        // Quando si ridimensiona in modalità desktop
        sidebar.classList.remove('is-open'); // Rimuovi la classe open del mobile
        sidebar.style.transform = ''; // Reset della trasformazione mobile
        mapContainer.style.height = '100%'; // Ripristina l'altezza completa della mappa
        if (clickOutsideListener) { // Rimuovi il listener se si passa a desktop
            document.removeEventListener('click', clickOutsideListener);
            clickOutsideListener = null;
        }
        map.resize(); // Ridimensiona la mappa dopo il cambio di layout
    } else {
        // Quando si ridimensiona in modalità mobile
        setMobileSidebarState(false); // Collassa il menu e regola l'altezza della mappa
    }
});
</script>
</body>
</html>
